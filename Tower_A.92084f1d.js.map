{"mappings":"ACAA,OAAO,gBAAgB,CAAC,mBAAoB,KACxC,IAAM,EAAM,SAAS,cAAc,CAAC,YAC9B,EAAQ,SAAS,gBAAgB,CAAC,gBACxC,GAAI,CAAC,GAAO,CAAC,EAAM,MAAM,CAAE,OAE3B,IAAI,EAAgB,KAQpB,SAAS,EAAc,CAAC,CAAE,CAAC,EAEvB,EAAI,KAAK,CAAC,IAAI,CAAG,EAAI,KACrB,EAAI,KAAK,CAAC,GAAG,CAAI,EAVJ,GAUoB,KAGjC,IAAM,EAAI,EAAI,qBAAqB,GAC7B,EAAQ,EAAE,KAAK,CAAG,EAEpB,EAAW,EACf,EAAW,KAAK,GAAG,CAAC,EAhBR,EAgByB,GACrC,EAAW,KAAK,GAAG,CAAC,OAAO,UAAU,CAAG,EAjB5B,EAiB6C,GAEzD,IAAI,EAAW,EApBF,EAwBT,CADe,EAFN,EAAE,MAAM,CApBT,GAyBR,EAAI,KAAK,CAAC,SAAS,CAAG,uBACtB,EAAW,GAEX,EAAI,KAAK,CAAC,SAAS,CAAG,yBAG1B,EAAI,KAAK,CAAC,IAAI,CAAG,EAAW,KAC5B,EAAI,KAAK,CAAC,GAAG,CAAG,EAAW,IAC/B,CASA,SAAS,IACL,EAAI,SAAS,CAAC,MAAM,CAAC,cACrB,EAAI,YAAY,CAAC,cAAe,QAChC,EAAgB,IACpB,CAEA,EAAM,OAAO,CAAC,AAAA,IACV,EAAE,gBAAgB,CAAC,aAAc,AAAC,IAC9B,EAAgB,EAdpB,EAAI,WAAW,CAjCR,AAgDK,EAhDF,YAAY,CAAC,cAAgB,AAgD3B,EAhD8B,EAAE,EAAI,QAkChD,EAAI,SAAS,CAAC,GAAG,CAAC,cAClB,EAAI,YAAY,CAAC,cAAe,SAChC,EAAc,AAYC,EAZC,OAAO,CAAE,AAYV,EAZY,OAAO,CAalC,GACA,EAAE,gBAAgB,CAAC,YAAa,AAAC,IACzB,IAAkB,GAAG,EAAc,EAAE,OAAO,CAAE,EAAE,OAAO,CAC/D,GACA,EAAE,gBAAgB,CAAC,aAAc,EACrC,GAGA,OAAO,gBAAgB,CAAC,SAAU,IAAM,EAAI,SAAS,CAAC,QAAQ,CAAC,eAAiB,EAAI,KAAK,CAAC,GAAG,EAC7F,OAAO,gBAAgB,CAAC,SAAU,IAAM,EAAI,SAAS,CAAC,QAAQ,CAAC,eAAiB,EAAI,KAAK,CAAC,IAAI,EAC9F,OAAO,gBAAgB,CAAC,oBAAqB,IAAM,IACvD","sources":["<anon>","src/JS/HoverName.js"],"sourcesContent":["window.addEventListener('DOMContentLoaded', ()=>{\n    const tip = document.getElementById('floorTip');\n    const paths = document.querySelectorAll('.Cutout path');\n    if (!tip || !paths.length) return;\n    let currentTarget = null;\n    const OFFSET_Y = 16; // how far above the cursor the tooltip sits\n    const PADDING = 8; // viewport padding so it never clips\n    function labelFor(el) {\n        return el.getAttribute('data-name') || el.id || 'Floor';\n    }\n    function positionTipAt(x, y) {\n        // place roughly above cursor\n        tip.style.left = x + 'px';\n        tip.style.top = y - OFFSET_Y + 'px';\n        // keep fully on-screen (considering transform: translate(-50%, -100%))\n        const r = tip.getBoundingClientRect();\n        const halfW = r.width / 2;\n        let clampedX = x;\n        clampedX = Math.max(halfW + PADDING, clampedX);\n        clampedX = Math.min(window.innerWidth - halfW - PADDING, clampedX);\n        let clampedY = y - OFFSET_Y; // already above cursor\n        const tipH = r.height;\n        // since we translateY(-100%), the visible top = clampedY - tipH\n        const visibleTop = clampedY - tipH;\n        if (visibleTop < PADDING) {\n            // if too close to top, move it below the cursor instead\n            tip.style.transform = 'translate(-50%, 8px)'; // small gap below cursor\n            clampedY = y;\n        } else tip.style.transform = 'translate(-50%, -100%)';\n        tip.style.left = clampedX + 'px';\n        tip.style.top = clampedY + 'px';\n    }\n    function showTip(el, e) {\n        tip.textContent = labelFor(el);\n        tip.classList.add('is-visible');\n        tip.setAttribute('aria-hidden', 'false');\n        positionTipAt(e.clientX, e.clientY);\n    }\n    function hideTip() {\n        tip.classList.remove('is-visible');\n        tip.setAttribute('aria-hidden', 'true');\n        currentTarget = null;\n    }\n    paths.forEach((p)=>{\n        p.addEventListener('mouseenter', (e)=>{\n            currentTarget = p;\n            showTip(p, e);\n        });\n        p.addEventListener('mousemove', (e)=>{\n            if (currentTarget === p) positionTipAt(e.clientX, e.clientY);\n        });\n        p.addEventListener('mouseleave', hideTip);\n    });\n    // safety: if user scrolls/resizes while hovering, keep following last cursor pos\n    window.addEventListener('scroll', ()=>tip.classList.contains('is-visible') && tip.style.top);\n    window.addEventListener('resize', ()=>tip.classList.contains('is-visible') && tip.style.left);\n    window.addEventListener('orientationchange', ()=>hideTip());\n});\n\n//# sourceMappingURL=Tower_A.92084f1d.js.map\n","window.addEventListener('DOMContentLoaded', () => {\r\n    const tip = document.getElementById('floorTip');\r\n    const paths = document.querySelectorAll('.Cutout path');\r\n    if (!tip || !paths.length) return;\r\n\r\n    let currentTarget = null;\r\n    const OFFSET_Y = 16; // how far above the cursor the tooltip sits\r\n    const PADDING = 8;   // viewport padding so it never clips\r\n\r\n    function labelFor(el) {\r\n        return el.getAttribute('data-name') || el.id || 'Floor';\r\n    }\r\n\r\n    function positionTipAt(x, y) {\r\n        // place roughly above cursor\r\n        tip.style.left = x + 'px';\r\n        tip.style.top = (y - OFFSET_Y) + 'px';\r\n\r\n        // keep fully on-screen (considering transform: translate(-50%, -100%))\r\n        const r = tip.getBoundingClientRect();\r\n        const halfW = r.width / 2;\r\n\r\n        let clampedX = x;\r\n        clampedX = Math.max(halfW + PADDING, clampedX);\r\n        clampedX = Math.min(window.innerWidth - halfW - PADDING, clampedX);\r\n\r\n        let clampedY = y - OFFSET_Y; // already above cursor\r\n        const tipH = r.height;\r\n        // since we translateY(-100%), the visible top = clampedY - tipH\r\n        const visibleTop = clampedY - tipH;\r\n        if (visibleTop < PADDING) {\r\n            // if too close to top, move it below the cursor instead\r\n            tip.style.transform = 'translate(-50%, 8px)'; // small gap below cursor\r\n            clampedY = y;\r\n        } else {\r\n            tip.style.transform = 'translate(-50%, -100%)';\r\n        }\r\n\r\n        tip.style.left = clampedX + 'px';\r\n        tip.style.top = clampedY + 'px';\r\n    }\r\n\r\n    function showTip(el, e) {\r\n        tip.textContent = labelFor(el);\r\n        tip.classList.add('is-visible');\r\n        tip.setAttribute('aria-hidden', 'false');\r\n        positionTipAt(e.clientX, e.clientY);\r\n    }\r\n\r\n    function hideTip() {\r\n        tip.classList.remove('is-visible');\r\n        tip.setAttribute('aria-hidden', 'true');\r\n        currentTarget = null;\r\n    }\r\n\r\n    paths.forEach(p => {\r\n        p.addEventListener('mouseenter', (e) => {\r\n            currentTarget = p;\r\n            showTip(p, e);\r\n        });\r\n        p.addEventListener('mousemove', (e) => {\r\n            if (currentTarget === p) positionTipAt(e.clientX, e.clientY);\r\n        });\r\n        p.addEventListener('mouseleave', hideTip);\r\n    });\r\n\r\n    // safety: if user scrolls/resizes while hovering, keep following last cursor pos\r\n    window.addEventListener('scroll', () => tip.classList.contains('is-visible') && tip.style.top);\r\n    window.addEventListener('resize', () => tip.classList.contains('is-visible') && tip.style.left);\r\n    window.addEventListener('orientationchange', () => hideTip());\r\n});"],"names":["window","addEventListener","tip","document","getElementById","paths","querySelectorAll","length","currentTarget","positionTipAt","x","y","style","left","top","r","getBoundingClientRect","halfW","width","clampedX","Math","max","min","innerWidth","clampedY","visibleTop","height","transform","hideTip","classList","remove","setAttribute","forEach","p","e","textContent","el","getAttribute","id","add","clientX","clientY","contains"],"version":3,"file":"Tower_A.92084f1d.js.map"}